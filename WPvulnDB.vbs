'WordPress Plugin Vulnerability Checker (companion script for WordPress_Plugin_Enum.vbs)
'Utilizes the WPScan Vulnerability Database - https://wpvulndb.com/api
'Gets CVSS via http://cve.circl.lu/api

'Copyright (c) 2018 Ryan Boyle randomrhythm@rhythmengineering.com.

'This program is free software: you can redistribute it and/or modify
'it under the terms of the GNU General Public License as published by
'the Free Software Foundation, either version 3 of the License, or
'(at your option) any later version.

'This program is distributed in the hope that it will be useful,
'but WITHOUT ANY WARRANTY; without even the implied warranty of
'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
'GNU General Public License for more details.

'You should have received a copy of the GNU General Public License
'along with this program.  If not, see <http://www.gnu.org/licenses/>.

Const forwriting = 2
Const ForAppending = 8
Const ForReading = 1
Dim CurrentDirectory
Dim strWPvulnDBapiKEy
strWPvulnDBapiKEy = ""


strRandom = "4bv3nT9vrkJpj3QyueTvYFBMIvMOllyuKy3d401Fxaho6DQTbPafyVmfk8wj1bXF" 'encryption key. Change if you want but can only decrypt with same key

CurrentDirectory = GetFilePath(wscript.ScriptFullName)

strFile = CurrentDirectory & "\wpvdb.dat"

Set objFSO = CreateObject("Scripting.FileSystemObject")

if objFSO.fileexists(strFile) then
  Set objFile = objFSO.OpenTextFile(strFile)
  if not objFile.AtEndOfStream then 'read file
      'On Error Resume Next
      strData = objFile.ReadLine 
      'on error goto 0
  end if
  if strData <> "" then
    strData = Decrypt(strData,strRandom)
      strWPvulnDBapiKEy = strData
      strData = ""
  end if
end if
on error resume next
objFile.close
on error goto 0

if not objFSO.fileexists(strFile) and strData = "" then
  strWPvulnDBapiKEy = inputbox("Enter your WPScan Vulnerability Database api key")
  if strWPvulnDBapiKEy <> "" then
    strTempEncryptedAPIKey = encrypt(strWPvulnDBapiKEy,strRandom)
    logdata strFile,strTempEncryptedAPIKey,False
  else
    msgbox "No API key provided. Exiting"
    wscript.quit(2)
  end if
end if


if objFSO.fileexists(CurrentDirectory &"\WP_Plugins.txt") then
  LogData CurrentDirectory & "\WP_Plugin_Vuln.txt", "Plugin Name|Installed Version|Patched Version|Latest Version|Vuln Type|CVE|CVSS|Vuln Title|References", false
  Set objFile = objFSO.OpenTextFile(CurrentDirectory &"\WP_Plugins.txt")
  Do While Not objFile.AtEndOfStream
    if not objFile.AtEndOfStream then 'read file
        On Error Resume Next
        strData = objFile.ReadLine 
        on error goto 0
        if instr(strData,"|") > 0 then
          strTmpArray = split(strData, "|")
          if ubound(strTmpArray) > 1 then
            CheckWPvulnDB strTmpArray(0), strTmpArray(2)
          else
            msgbox "WP_Plugins.txt not formatted correctly"
          end if
          wscript.sleep 15000
        end if

        on error goto 0
    end if
  loop
else
  BoolDDNS_Checks = False
end if

Function CheckWPvulnDB(strWP_Plugin, StrWP_Version)
Set objHTTP = CreateObject("MSXML2.ServerXMLHTTP")
Dim strAPIurl
strAPIurl = "https://wpvulndb.com/api/v3/plugins/" & strWP_Plugin

objHTTP.open "GET", strAPIurl, False

objHTTP.setRequestHeader "Authorization", "Token token=" &  strWPvulnDBapiKEy

on error resume next
objHTTP.send 
if err.number <> 0 then
  logdata CurrentDirectory & "\Error.log", Date & " " & Time & " WPScan Vulnerability Database API lookup failed with HTTP error. - " & err.description,False 
  exit function 
end if
on error goto 0  

if BoolDebugTrace = True then logdata strDebugPath & "\WPScan" & "" & ".txt", objHTTP.responseText & vbcrlf & vbcrlf,BoolEchoLog 

vulnJSON = objHTTP.responseText
boolIsVuln = False
if instr(vulnJSON, chr(34) & "id" & chr(34)) then
  strLatestVersion = GetData(vulnJSON, chr(34), "latest_version" & Chr(34) & ":" & chr(34))
  arraySplit = split(vulnJSON, chr(34) & "id" & chr(34))
  for each strVulnText in arraySplit
    strTitle = GetData(strVulnText, chr(34), "title" & Chr(34) & ":" & chr(34))
    strVersion = GetData(strVulnText, chr(34), "fixed_in" & Chr(34) & ":" & chr(34))
    strVulnType = GetData(strVulnText, chr(34), "vuln_type" & Chr(34) & ":" & chr(34))
    strReferences = GetData(strVulnText, "}", "references" & Chr(34) & ":{" & chr(34))
    strCVE = GetData(strVulnText, chr(34), "cve" & Chr(34) & ":[" & chr(34))
    if isVersion(strVersion) = True then
      'msgbox strVersion & "|" & strTitle
      if FirstVersionSupOrEqualToSecondVersion(JustNumbers(StrWP_Version), strVersion) = False then
          strCVSS = ""
          if strCVE <> "" then 
            strCVSS = getCVSS(strCVE)
          end if
          LogData CurrentDirectory & "\WP_Plugin_Vuln.txt", strWP_Plugin & "|" & StrWP_Version & "|" & strVersion  & "|" & strLatestVersion & "|" & strVulnType & "|" & strCVE & "|" & strCVSS & "|" & strTitle & "|" &  strReferences, false
          boolIsVuln = True
      end if
      LogData CurrentDirectory & "\WP_Plugin_Debug.log", strWP_Plugin & "|" & StrWP_Version & "|" & strVersion & "|" & strLatestVersion & "|" & strVulnType & "|" & strCVE & "||" & strTitle & "|" & strReferences, false
    end if
  next
  if boolIsVuln = False then
    LogData CurrentDirectory & "\WP_Plugin_NoVuln.txt", strWP_Plugin & "|" & StrWP_Version & "|" & "" & "|" & "" & "|" & strLatestVersion, false
  end if
elseif instr(vulnJSON, chr(34) & "latest_version" & chr(34)) > 0 then
  strLatestVersion = GetData(vulnJSON, chr(34), "latest_version" & Chr(34) & ":" & chr(34))
  LogData CurrentDirectory & "\WP_Plugin_NoVuln.txt", strWP_Plugin & "|" & StrWP_Version & "|" & "" & "|" & "" & "|" & strLatestVersion, false
elseif instr(vulnJSON, chr(34) & "Not found" & chr(34)) > 0 then
  LogData CurrentDirectory & "\WP_Plugin_NoInfo.txt", strWP_Plugin & "|" & StrWP_Version & "|" & "" & "|" & "", false
elseif objHTTP.status = "401" then
  objFSO.deletefile(CurrentDirectory & "\wpvdb.dat")
  msgbox "Access has been denied. API key file " & chr(34) & CurrentDirectory & "\wpvdb.dat" & chr(34) & " has been deleted. Please double check API key and try again"
  wscript.quit(4)
else
  msgbox "error response: " & objHTTP.status & " " & vulnJSON
end if
 
Set objHTTP = Nothing
end Function


Function getCVSS(strCVE)
Set objHTTPcve = CreateObject("MSXML2.ServerXMLHTTP")
Dim strCVEurl
Dim strVulnCVE
strVulnCVE = ""
strCVEurl = "http://cve.circl.lu/api/cve/CVE-" & strCVE

objHTTPcve.open "GET", strCVEurl, False

on error resume next
  objHTTPcve.send 
  if err.number <> 0 then
    logdata CurrentDirectory & "\Error.log", Date & " " & Time & " cve.circl.lu API lookup failed with HTTP error. - " & err.description,False 
    exit function 
  end if
on error goto 0  
BoolDebugTrace = True
if BoolDebugTrace = True then logdata strDebugPath & "\cve" & "" & ".txt", objHTTPcve.responseText & vbcrlf & vbcrlf,BoolEchoLog 
strResponseText = objHTTPcve.responseText
if instr(strResponseText, chr(34) & "cvss" & chr(34)) then
  strVulnCVE = GetData(strResponseText, ",", chr(34) & "cvss" & Chr(34) & ": ")
end if
getCVSS = strVulnCVE
end function


Function isVersion(strIPaddress)
boolIsVersion = False
if len(strIPaddress) > 1 then
  if isnumeric(left(strIPaddress, 1)) = True then 
    boolIsVersion = True
  elseif len(strIPaddress) > 2 then
    if left(strIPaddress, 1) = "." then
      if isnumeric(mid(strIPaddress, 2, 1)) then
        boolIsVersion = True
      end if
    end if
  end if
end if
isVersion = boolIsVersion
end function

Function JustNumbers(strVersionNum)
DIm strReturnNumbers
For x = 1 to len(strVersionNum)
  if isnumeric(mid(strVersionNum, x,1)) or mid(strVersionNum, x,1) = "." then
    strReturnNumbers = strReturnNumbers & mid(strVersionNum, x,1)
  end if
next
JustNumbers = strReturnNumbers
end Function

Function removeInvalidVersion(strVersionNumber)
Dim StrReturnValidVersion

if instr(strVersionNumber, " ") > 0 then
    StrReturnValidVersion = left(strVersionNumber, instr(strVersionNumber, " "))
else
  StrReturnValidVersion = strVersionNumber
end if
if instr(StrReturnValidVersion, ",") > 0 then
  StrReturnValidVersion = replace(StrReturnValidVersion, ",", ".")
end if
removeInvalidVersion = StrReturnValidVersion
end function

Function FirstVersionSupOrEqualToSecondVersion(strTmpFirstVersion, strTmpSecondVersion)
StrTmpVersionNumber = removeInvalidVersion(strTmpFirstVersion)	
strFirstVersion = StrTmpVersionNumber
StrTmpVersionNumber = removeInvalidVersion(strTmpSecondVersion)	
strSecondVersion = StrTmpVersionNumber
if boolDebugVersionCompare = True then msgbox "version compare " & strFirstVersion & vbcrlf & strSecondVersion
Dim arrFirstVersion,  arrSecondVersion, i, iStop, iMax
Dim iFirstArraySize, iSecondArraySize
Dim blnArraySameSize : blnArraySameSize = False

If strFirstVersion = strSecondVersion Then
  FirstVersionSupOrEqualToSecondVersion = True
  Exit Function
End If

If strFirstVersion = "" Then
  FirstVersionSupOrEqualToSecondVersion = False
  Exit Function
End If
If strSecondVersion = "" Then
  FirstVersionSupOrEqualToSecondVersion = True
  Exit Function
End If
if isnumeric(replace(strFirstVersion, ".", "")) = false then
  msgbox "Error converting version number due to non numeric value in the fist listed version: " & strFirstVersion
  exit function
end if
if isnumeric(replace(strSecondVersion, ".", "")) = false then
  msgbox "Error converting version number due to non numeric value in the second listed version: " & strSecondVersion
  exit function
end if
arrFirstVersion = Split(strFirstVersion, "." )
arrSecondVersion = Split(strSecondVersion, "." )
iFirstArraySize = UBound(arrFirstVersion)
iSecondArraySize = UBound(arrSecondVersion)

If iFirstArraySize = iSecondArraySize Then
  blnArraySameSize = True
  iStop = iFirstArraySize
  For i=0 To iStop
    'msgbox "arrFirstVersion=" & arrFirstVersion(i) & vbcrlf & "arrSecondVersion=" & arrSecondVersion(i)
    If clng(arrFirstVersion(i)) < clng(arrSecondVersion(i)) Then
      FirstVersionSupOrEqualToSecondVersion = False
      Exit Function
    elseif clng(arrFirstVersion(i)) > clng(arrSecondVersion(i)) then
      FirstVersionSupOrEqualToSecondVersion = True
      Exit Function			
    End If
  Next
  FirstVersionSupOrEqualToSecondVersion = True
Else
  If iFirstArraySize > iSecondArraySize Then
    iStop = iSecondArraySize
  Else
    iStop = iFirstArraySize
  End If
  For i=0 To iStop
    If clng(arrFirstVersion(i)) < clng(arrSecondVersion(i)) Then
      FirstVersionSupOrEqualToSecondVersion = False
      Exit Function
    else
      FirstVersionSupOrEqualToSecondVersion = True
      Exit Function
	End If
  Next
  If iFirstArraySize > iSecondArraySize Then
    FirstVersionSupOrEqualToSecondVersion = True
    Exit Function
  Else
    For i=iStop+1 To iSecondArraySize
      If clng(arrSecondVersion(i)) > 0 Then
        FirstVersionSupOrEqualToSecondVersion = False
        Exit Function
      End If
    Next
    FirstVersionSupOrEqualToSecondVersion = True
  End If
End If
End Function



Function GetData(contents, ByVal EndOfStringChar, ByVal MatchString)
MatchStringLength = Len(MatchString)
x= instr(contents, MatchString)

  if X >0 then
    strSubContents = Mid(contents, x + MatchStringLength, len(contents) - MatchStringLength - x +1)
    if instr(strSubContents,EndOfStringChar) > 0 then
      GetData = Mid(contents, x + MatchStringLength, instr(strSubContents,EndOfStringChar) -1)
      'msgbox "success:" & Mid(contents, x + MatchStringLength, instr(Mid(contents, x + MatchStringLength, len(contents) -x),EndOfStringChar) -1)
      exit function
    else
      GetData = Mid(contents, x + MatchStringLength, len(contents) -x -1)
      'msgbox "failed match:" & Mid(contents, x + MatchStringLength, len(contents) -x -1)
      exit function
    end if
    
  end if
GetData = ""

end Function



function LogData(TextFileName, TextToWrite,EchoOn)
Set fsoLogData = CreateObject("Scripting.FileSystemObject")
if EchoOn = True then wscript.echo TextToWrite
  If fsoLogData.fileexists(TextFileName) = False Then
      'Creates a replacement text file 
      on error resume next
      fsoLogData.CreateTextFile TextFileName, True
      if err.number <> 0 and err.number <> 53 then msgbox "Logging error: " & err.number & " " & err.description & vbcrlf & TextFileName
      on error goto 0
  End If
if TextFileName <> "" then


  Set WriteTextFile = fsoLogData.OpenTextFile(TextFileName,ForAppending, False)
  on error resume next
  WriteTextFile.WriteLine TextToWrite
  if err.number <> 0 then 
    on error goto 0
    WriteTextFile.Close
  Dim objStream
  Set objStream = CreateObject("ADODB.Stream")
  objStream.CharSet = "utf-16"
  objStream.Open
  objStream.WriteText TextToWrite
  on error resume next
  objStream.SaveToFile TextFileName, 2
  if err.number <> 0 then msgbox err.number & " - " & err.message & " Problem writting to " & TextFileName
  if err.number <> 0 then msgbox "problem writting text: " & TextToWrite
  on error goto 0
  Set objStream = nothing
  end if
end if
Set fsoLogData = Nothing
End Function


Function GetFilePath (ByVal FilePathName)
found = False

Z = 1

Do While found = False and Z < Len((FilePathName))

 Z = Z + 1

         If InStr(Right((FilePathName), Z), "\") <> 0 And found = False Then
          mytempdata = Left(FilePathName, Len(FilePathName) - Z)
          
             GetFilePath = mytempdata

             found = True

        End If      

Loop
end function



Function encrypt(StrText, key) 'Rafael Paran? - https://gallery.technet.microsoft.com/scriptcenter/e0d5d71c-313e-4ac1-81bf-0e016aad3cd2
  Dim lenKey, KeyPos, LenStr, x, Newstr 
   
  Newstr = "" 
  lenKey = Len(key) 
  KeyPos = 1 
  LenStr = Len(StrText) 
  StrTmpText = StrReverse(StrText) 
  For x = 1 To LenStr 
       Newstr = Newstr & chr(asc(Mid(StrTmpText,x,1)) + Asc(Mid(key,KeyPos,1))) 
       KeyPos = keypos+1 
       If KeyPos > lenKey Then KeyPos = 1 
       'if x = 4 then msgbox "error with char " & Chr(34) & asc(Mid(StrTmpText,x,1)) - Asc(Mid(key,KeyPos,1)) & Chr(34) & " At position " & KeyPos & vbcrlf & Mid(StrTmpText,x,1) & Mid(key,KeyPos,1) & vbcrlf & asc(Mid(StrTmpText,x,1)) & asc(Mid(key,KeyPos,1))
  Next 
  encrypt = Newstr 
End Function 

Function Decrypt(StrText,key) 
  Dim lenKey, KeyPos, LenStr, x, Newstr 
   
  Newstr = "" 
  lenKey = Len(key) 
  KeyPos = 1 
  LenStr = Len(StrText) 
   
  StrText=StrReverse(StrText) 
  For x = LenStr To 1 Step -1 
       on error resume next
       Newstr = Newstr & chr(asc(Mid(StrText,x,1)) - Asc(Mid(key,KeyPos,1))) 
       if err.number <> 0 then
        msgbox "error with char " & Chr(34) & asc(Mid(StrText,x,1)) - Asc(Mid(key,KeyPos,1)) & Chr(34) & " At position " & KeyPos & vbcrlf & Mid(StrText,x,1) & Mid(key,KeyPos,1) & vbcrlf & asc(Mid(StrText,x,1)) & asc(Mid(key,KeyPos,1))
        wscript.quit(011)
       end if
       on error goto 0
       KeyPos = KeyPos+1 
       If KeyPos > lenKey Then KeyPos = 1 
       Next 
       Newstr=StrReverse(Newstr) 
       Decrypt = Newstr 
 End Function 